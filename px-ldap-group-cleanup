#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# pylint: disable=invalid-name

# Copyright:
#   2020 P. H. <github.com/perfide>
# License:
#   BSD-2-Clause (BSD 2-Clause "Simplified" License)
#   https://spdx.org/licenses/BSD-2-Clause.html

"""LDAP group cleaner"""

# included
import argparse
import getpass
import logging
import os
import sys
import termios
import tty

# 3rd-party
import ldap3  # pip3 install ldap3 / sudo apt-get install python3-ldap3
import yaml  # pip3 install PyYAML / sudo apt-get install python3-yaml

DUMMY_USER = 'cn=delme'

LOG = logging.getLogger('px-ldap-group-cleanup')
LOG.setLevel(logging.DEBUG)
LOG_HANDLER = logging.StreamHandler()
LOG_HANDLER.setLevel(logging.DEBUG)
LOG.addHandler(LOG_HANDLER)


class BadNoneValue(Exception):
    """Raise an error if an argument is None"""
    def __init__(self, argument):
        Exception.__init__(self)
        self.argument = argument

    def __str__(self):
        return 'argument {}: can not be None'.format(self.argument)


class LdapOperationFailed(Exception):
    """Exception raised if an LDAP operation failed"""


def getc():
    """Read a single character from stdin

    Arguments:
        None

    Returns:
        str: a single character

    """
    file_descriptor = sys.stdin.fileno()
    old_settings = termios.tcgetattr(file_descriptor)
    try:
        tty.setraw(sys.stdin.fileno())
        char = sys.stdin.read(1)
    finally:
        termios.tcsetattr(file_descriptor, termios.TCSADRAIN, old_settings)
    return char


def force_getc(opts):
    """Let the user chose from a list of characters

    Arguments:
        opts (iterable): allowed characters

    Returns:
        None

    """
    print('please press:', end='')
    for key, desc in sorted(opts.items()):
        print(' [{}] {}'.format(key, desc), end='')
    print('')
    while True:
        char = getc()
        if char == '\x03':
            # ctrl+c
            raise KeyboardInterrupt
        if char in opts:
            return char
        print(
            'you pressed {!r} which is not in [{}]'.format(
                char,
                ' '.join(opts.keys()),
            )
        )
    # never reached
    return ''


def get_user_feedback():
    """Ask user how to proceed

    Args: None

    Returns:
        tuple: Modified ask_user and modify_group variables

    """
    ask_user = True
    modify_group = False
    opts = {
        'y': 'yes once',
        'n': 'no one',
        'a': 'yes to all',
        'q': 'no to all',
    }
    char = force_getc(opts)
    if char == 'y':
        modify_group = True
    if char == 'a':
        ask_user = False
        modify_group = True
    if char == 'q':
        ask_user = False
    return (ask_user, modify_group)


def handle_group(conn, entry, user_dns, ask_user, modify_group):
    """Search LDAP for inetOrgPerson objects

    Args:
        conn (ldap3.core.connection.Connection): The connected LDAP object
        entry (dict): The items of a LDAP object
        user_dns (set): The set of all known User-DNs
        ask_user (bool): If User-Feedback is required
        modify_group (bool): If the group should be cleaned

    Returns:
        tuple: Modified ask_user and modify_group variables

    """
    LOG.info('dn: "{}"'.format(entry['dn']))
    LOG.info('cn: "{}"'.format('~'.join(entry['attributes']['cn'])))
    LOG.info(
        'description: "{}"'.format(
            '~'.join(entry['attributes']['description'])
        )
    )
    mixed_unique_members = entry['attributes']['uniqueMember']
    unique_members = {member.lower() for member in mixed_unique_members}
    keep_members = unique_members & user_dns
    remove_members = sorted(unique_members - user_dns)
    LOG.info('count all: {}'.format(len(unique_members)))
    LOG.info('count keep: {}'.format(len(keep_members)))
    LOG.info('count remove: {}'.format(len(remove_members)))
    if remove_members:
        LOG.info('remove DNs:')
        for remove_member in remove_members:
            LOG.info('  {}'.format(remove_member))
        if ask_user:
            (ask_user, modify_group) = get_user_feedback()

        if modify_group:
            if not keep_members:
                LOG.info('adding a dummy...')
                conn.modify(
                    entry['dn'],
                    {'uniqueMember': [(ldap3.MODIFY_ADD, [DUMMY_USER])]},
                )
                if conn.result['result'] == 0:
                    LOG.info('success')
                else:
                    LOG.info(
                        'modification failed: {} ({})'.format(
                            conn.result['description'], conn.result['result']
                        )
                    )
                    LOG.info(conn.result)

            LOG.info('removing...')
            conn.modify(
                entry['dn'],
                {'uniqueMember': [(ldap3.MODIFY_DELETE, remove_members)]},
            )
            if conn.result['result'] == 0:
                LOG.info('success')
            else:
                LOG.info(
                    'modification failed: {} ({})'.format(
                        conn.result['description'], conn.result['result']
                    )
                )
                LOG.info(conn.result)

        else:
            LOG.info('skipping...')
    return (ask_user, modify_group)


def get_user_dns(conn, search_base):
    """Search LDAP for inetOrgPerson objects

    Args:
        conn (ldap3.core.connection.Connection): a connected LDAP object
        search_base (str): base-dn to be used for the search

    Returns:
        set: user-DNs

    """
    user_dns = set()
    LOG.info('searching for inetOrgPerson')
    try:
        search_result = conn.search(
            search_base=search_base,
            search_filter='(objectclass=inetOrgPerson)',
            search_scope=ldap3.SUBTREE,
            attributes=[],
            time_limit=1,
        )
    except ldap3.core.exceptions.LDAPSocketReceiveError as err:
        # error receiving data: The read operation timed out
        LOG.error('timeout while searching for users: {}'.format(err))
        return user_dns
    if not search_result or conn.result['result'] != 0:
        raise LdapOperationFailed(f'user-search failed: {conn.result}')
    assert conn.result['description'] == 'success'
    assert conn.result['dn'] == ''
    assert conn.result['message'] == ''
    assert conn.result['referrals'] is None
    assert conn.result['type'] == 'searchResDone'
    LOG.info('search-results: {}'.format(len(conn.response)))
    for entry in conn.response:
        distingished_name = entry['dn'].lower()
        LOG.info("- {}".format(distingished_name))
        user_dns.add(distingished_name)
    return user_dns


def prepare_parameters(arguments):
    """Parse command-line arguments

    Args:
        arguments (list): command-line arguments without the programm-name

    Returns:
        dict: parsed arguments

    """
    config_path = os.path.join(
        os.path.expanduser('~'), '.config', 'px-ldap-group-cleanup.yaml'
    )
    try:
        with open(config_path) as file_handler:
            cfg = yaml.safe_load(file_handler)
    except FileNotFoundError:
        LOG.warning('config not found at: {}'.format(config_path))
        cfg = {}
    if cfg is None:
        LOG.warning('empty config found at: {}'.format(config_path))
        cfg = {}

    parser = argparse.ArgumentParser(
        description='Use a yaml-config to render Jinja2 templates'
    )
    parser.add_argument('-H', '--host', help='Domain Name, IP or LDAP-URL')
    parser.add_argument('-D', '--bind-dn', help='users distingushed name')
    parser.add_argument('-w', '--bind-pw', help='users password')
    parser.add_argument('-b', '--search-base', help='base-dn for searches')
    parser.set_defaults(**cfg)
    namespace = parser.parse_args(arguments)

    if namespace.host is None:
        parser.print_usage()
        raise BadNoneValue('-H/--host')
    if namespace.bind_dn is None:
        parser.print_usage()
        raise BadNoneValue('-D/--bind-dn')
    if namespace.bind_pw is None:
        namespace.bind_pw = getpass.getpass()
    if namespace.search_base is None:
        parser.print_usage()
        raise BadNoneValue('-b/--search-base')
    return vars(namespace)


def main(arguments):
    """Handle the groups cleanup

    Args:
        arguments (list): command-line arguments without the programm-name

    Returns:
        int: exit code

    """
    ask_user = True
    modify_group = False
    parameters = prepare_parameters(arguments)

    LOG.debug('creating server')
    server = ldap3.Server(parameters['host'], get_info=ldap3.ALL)
    LOG.debug('creating connection')
    conn = ldap3.Connection(
        server,
        user=parameters['bind_dn'],
        password=parameters['bind_pw'],
        auto_bind=False,
        receive_timeout=2,
    )
    LOG.debug('starting TLS')
    try:
        start_tls_result = conn.start_tls()
    except ldap3.core.exceptions.LDAPSocketOpenError as err:
        LOG.error('failed to open socket: {}'.format(err))
        return 1
    except ldap3.core.exceptions.LDAPStartTLSError as err:
        # wrap socket error: _ssl.c:835: The handshake operation timed out
        LOG.error('failed to start TLS: {}'.format(err))
        return 1
    except ldap3.core.exceptions.LDAPSocketReceiveError as err:
        # error receiving data: timed out
        LOG.error('timeout while connecting: {}'.format(err))
        return 1
    assert start_tls_result is True
    LOG.debug('authenticating')
    try:
        bind_result = conn.bind()
    except ldap3.core.exceptions.LDAPSocketReceiveError as err:
        # error receiving data: The read operation timed out
        LOG.error('timeout while binding: {}'.format(err))
        return 1
    if not bind_result:
        LOG.error('bind failed')
        return 2
    LOG.debug('fetching users')
    user_dns = get_user_dns(conn, parameters['search_base'])
    LOG.debug('found {} users'.format(len(user_dns)))
    # Keep the dummy-user
    user_dns.add(DUMMY_USER)
    LOG.info('searching for groupOfUniqueNames')
    search_result = conn.search(
        search_base=parameters['search_base'],
        search_filter='(objectclass=groupOfUniqueNames)',
        search_scope=ldap3.SUBTREE,
        attributes=['cn', 'uniqueMember', 'description'],
    )
    LOG.info('search_result {} ({})'.format(search_result, len(conn.response)))
    LOG.info('')

    for entry in conn.response:
        (ask_user, modify_group) = handle_group(
            conn,
            entry,
            user_dns,
            ask_user,
            modify_group,
        )
        LOG.info('')
    return 0


if __name__ == '__main__':
    try:
        sys.exit(main(sys.argv[1:]))
    except KeyboardInterrupt:
        LOG.error('\ninterrupted by keyboard')
    except BadNoneValue as err:
        LOG.error("{}: error: {}".format(sys.argv[0], err))

# [EOF]
